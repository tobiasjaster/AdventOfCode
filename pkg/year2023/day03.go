// Code generated by aocgen; DO NOT EDIT.
package year2023

import (
	"fmt"
	"strconv"
	"strings"
	"unicode"
)

type Number struct {
	value int
	positions []Position
}

type Position struct {
	hight int
	width int
}

func parse(lines []string) ([]Number, map[string]byte) {
	digits := []Number{}
	specials := map[string]byte{}
	for h, line := range lines {
		line = strings.ReplaceAll(line, "\n", "")
		line = strings.ReplaceAll(line, "\r", "")
		number := ""
		positions := []Position{}
		for v, b := range line {
			if b != rune(byte('.')) {
				if unicode.IsDigit(rune(b)) {
					number = number + string(b)
					positions = append(positions, Position{hight: h, width: v})
				}else{
					specials[fmt.Sprintf("%d,%d",h,v)] = byte(b)		
					if number != "" {
						nr,_ := strconv.Atoi(number)
						digits = append(digits, Number{
							value: nr,
							positions: positions,
						})
						number = ""
						positions = []Position{}
					}
				}
				continue
			}
			if number != "" {
				nr,_ := strconv.Atoi(number)
				digits = append(digits, Number{
					value: nr,
					positions: positions,
				})
				number = ""
				positions = []Position{}
			}
		}
		if number != "" {
			nr,_ := strconv.Atoi(number)
			digits = append(digits, Number{
				value: nr,
				positions: positions,
			})
		}
	}
	return digits, specials
}



type Day03 struct{}

func (p Day03) PartA(lines []string) any {

	digits, specials := parse(lines)
	count := 0
	for _,v := range digits {
		isSpecial := false
		for _, position := range v.positions {
			for i := position.hight -1; i <= position.hight+1; i++ {
				for j := position.width-1; j <= position.width+1; j++ {
					if _,ok := specials[fmt.Sprintf("%d,%d",i,j)]; ok {
						isSpecial = true
						break
					}
				}
				if isSpecial {
					break
				}
			}
			if isSpecial {
				break
			}
		}
		if isSpecial {
			count = count + v.value
		}
	}
	return count
}

func (p Day03) PartB(lines []string) any {

	digits, specials := parse(lines)
	gears := map[string][]int{}
	for _,v := range digits {
		isGear := false
		for _, position := range v.positions {
			for i := position.hight-1; i <= position.hight+1; i++ {
				for j := position.width-1; j <= position.width+1; j++ {
					if value,ok := specials[fmt.Sprintf("%d,%d",i,j)]; ok {
						if value == byte('*') {
							if gear,inside := gears[fmt.Sprintf("%d,%d",i,j)];!inside {
								gears[fmt.Sprintf("%d,%d",i,j)] = []int{v.value}
							}else{
								gear = append(gear, v.value)
								gears[fmt.Sprintf("%d,%d",i,j)] = gear
							}
							isGear = true
						}
					}
				}
				if isGear {
					break
				}
			}
			if isGear {
				break
			}
		}
	}
	count := 0
	for _,v :=range gears {
		if len(v)==2 {
			count = count+(v[0]*v[1])
		}
	}
	return count
}
