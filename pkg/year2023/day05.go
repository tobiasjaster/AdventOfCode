// Code generated by aocgen; DO NOT EDIT.
package year2023

import (
	"sort"
	"strconv"
	"strings"
)

type Day05 struct{}

type PositionDay5 struct {
	Start int
	Range int
}

type Map struct {
	Name string
	Converts []Convert
}

type Convert struct {
	Source int
	Destination int
	Range int
}

func parseDay5(lines []string) (seeds []int,mapconverts []Map) {
	seedsStr,_ := strings.CutPrefix(lines[0],"seeds: ")
	for _, seedStr := range strings.Split(seedsStr," ") {
		seed,_ := strconv.Atoi(seedStr)
		seeds = append(seeds, seed)
	}
	mapconvert := Map{
		Name: "",
		Converts: []Convert{},
	}
	for _, line := range lines[2:] {
		line = strings.ReplaceAll(line, "\n", "")
		line = strings.ReplaceAll(line, "\r", "")
		if strings.Contains(line, "map") {
			mapconvert.Name = line
			continue
		}
		if line == "" {
			mapconverts = append(mapconverts, mapconvert)
			mapconvert = Map{
				Name: "",
				Converts: []Convert{},
			}
			continue
		}
		values := strings.Split(line, " ")
		source,_ := strconv.Atoi(values[1])
		dest,_ := strconv.Atoi(values[0])
		dist,_ := strconv.Atoi(values[2])
		convert := Convert{
			Source: source,
			Destination: dest,
			Range: dist,
		}
		mapconvert.Converts = append(mapconvert.Converts, convert)
	}
	return
}

func (p Day05) PartA(lines []string) any {
	a,b := parseDay5(lines)
	converts := [][]int{a}
	for idx, convertmap := range b {
		destination := []int{}
		for _, start := range converts[idx] {
			found := false
			for _, convert := range convertmap.Converts {
				// fmt.Printf("%d < %d: %v\n", convert.Source, start, convert.Source < start)
				if convert.Source > start {
					continue
				}
				// fmt.Printf("%d > %d: %v\n", convert.Source+convert.Range, start, convert.Source > start)
				if convert.Source+convert.Range < start {
					continue
				}
				destination = append(destination, start-convert.Source+convert.Destination)
				found = true
				break
			}
			if !found {
				destination = append(destination, start)
			}
		}
		converts = append(converts, destination)
	}
	location := converts[len(converts)-1]
	sort.Ints(location)
	return location[0]
}

func (p Day05) PartB(lines []string) any {
	a,b := parseDay5(lines)
	positionDay5 := []PositionDay5{}
	for i:=0;i<(len(a)/2);i++{
		positionDay5 = append(positionDay5, PositionDay5{
			Start: a[(i*2)],
			Range: a[(i*2+1)],
		})
	}
	converts := [][]PositionDay5{positionDay5}
	for idx, convertmap := range b {
		destination := []PositionDay5{}
		for _, position := range converts[idx] {
			found := false
			recursePosition := position
			for{
				if recursePosition.Range <= 0 {
					break
				}
				nearestStart := -1
				found = false
				for _, convert := range convertmap.Converts {
					if convert.Source > recursePosition.Start {
						if nearestStart == -1 || nearestStart > convert.Source {
							nearestStart = convert.Source
						}
						continue
					}
					if convert.Source+convert.Range-1 < recursePosition.Start {
						continue
					}
					start := recursePosition.Start
					finish := -1
					if recursePosition.Start+recursePosition.Range-1>convert.Source+convert.Range-1 {
						finish = convert.Source+convert.Range-1
					}else{
						finish = recursePosition.Start+recursePosition.Range-1
					}
					destination = append(destination, PositionDay5{
						Start: start-convert.Source+convert.Destination,
						Range: finish-start,
					})
					oldrange := recursePosition.Range-1
					recursePosition = PositionDay5{
						Start: finish+1,
						Range: oldrange-(finish-start),
					}
					found = true
					break
				}
				if !found {
					if nearestStart <= -1 {
						nearestStart = recursePosition.Start+recursePosition.Range
					}
					start := recursePosition.Start
					finish := nearestStart-1
					destination = append(destination, PositionDay5{
						Start: start,
						Range: finish-start,
					})
					oldrange := recursePosition.Range-1
					recursePosition = PositionDay5{
						Start: finish+1,
						Range: oldrange-(finish-start),
					}
				}
			}
		}
		converts = append(converts, destination)
	}
	locations := converts[len(converts)-1]
	starts := []int{}
	for _, location := range locations {
		starts = append(starts, location.Start)
	}
	sort.Ints(starts)
	return starts[0]
}
