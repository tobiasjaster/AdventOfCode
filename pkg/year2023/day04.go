// Code generated by aocgen; DO NOT EDIT.
package year2023

import (
	"math"
	"strconv"
	"strings"
)

type Day04 struct{}

type Card struct {
	Count int
	Nr int
	Win []int
	Have []int
}

func parseLines(lines []string) []Card {
	cards := []Card{}
	for _, line := range lines {
		line = strings.ReplaceAll(line,"\n","")
		line = strings.ReplaceAll(line,"\r","")
		card := strings.Split(line,": ")
		cardNrStr,_ := strings.CutPrefix(card[0],"Card ")
		cardNr,_ := strconv.Atoi(cardNrStr)

		valuesRaw := strings.ReplaceAll(card[1], "  ", " ")
		values := strings.Split(valuesRaw," | ")
		win := []int{}
		for _, value := range strings.Split(values[0], " ") {
			nr,_:=strconv.Atoi(value)
			win = append(win, nr)
		}
		have := []int{}
		for _, value := range strings.Split(values[1], " ") {
			nr,_:=strconv.Atoi(value)
			have = append(have, nr)
		}
		cards = append(cards, Card{
			1, cardNr,win,have,
		})
	}
	return cards
}

func (p Day04) PartA(lines []string) any {
	cards := parseLines(lines)
	points := 0
	for _, card := range cards {
		count :=0
		for _, have := range card.Have {
			for _, win := range card.Win {
				if have == win {
					count = count + 1
				}
			}
		}
		if count > 0 {
			points = points + int(math.Pow(2, float64(count-1)))
		}
	}
	return points
}

func (p Day04) PartB(lines []string) any {
	cards := parseLines(lines)
	for idx, card := range cards {
		count :=0
		for _, have := range card.Have {
			for _, win := range card.Win {
				if have == win {
					count = count + 1
				}
			}
		}
		for i := 0; i<count;i++{
			if idx+i+1 >= len(cards) {
				continue
			}
			cards[idx+i+1].Count = cards[idx+i+1].Count+card.Count
		}
	}
	count := 0
	for _, card := range cards {
		count = count+ card.Count
	}
	return count
}
