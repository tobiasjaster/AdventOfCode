// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"errors"
	"sort"
)

type Day12 struct{}

type Position struct {
	X int
	Y int
}

type Direction struct {
	X int
	Y int
}

func NewPosition(x int,y int) *Position {
	p := new(Position)
	p.X = x
	p.Y = y
	return p
}

func NewDirection(x int,y int) *Direction {
	d := new(Direction)
	d.X = x
	d.Y = y
	return d
}

func FindPositionInList(search Position, posList []Position) (int, error) {
	for i, pos := range posList {
		if search.X == pos.X && search.Y == pos.Y {
			return i, nil
		}
	}
	return 0, errors.New("not_in_list")
}

func Search(start Position, end Position, game [][]rune) [][]int {
	frontier := []Position{start}
	distances := make([][]int, len(game))
	for i := range distances {
		distances[i] = make([]int, len(game[0]))
	}
	visited := []Position{}
	distances[start.Y][start.Y] = 0
	moves := map[string]Direction{"r":*NewDirection(0,1),"l":*NewDirection(0,-1),"u":*NewDirection(-1,0),"d":*NewDirection(1,0)}
	for ok := true; ok; ok = len(frontier)>0 {
		actPosition := frontier[0]
		frontier = frontier[1:]
		if actPosition.X == end.X && actPosition.Y == end.Y {
			break
		}
		_, err := FindPositionInList(actPosition, visited)
		if err != nil {
			visited = append(visited, actPosition)
			for _, move := range moves {
				newPosition := *NewPosition(actPosition.X + move.X, actPosition.Y + move.Y)
				if !(newPosition.X >= 0 && newPosition.X < len(game[0]) && newPosition.Y >= 0 && newPosition.Y < len(game)) {
					continue
				}
				if int(game[newPosition.Y][newPosition.X])-int(game[actPosition.Y][actPosition.X])>1 {
					continue
				}
				if distances[newPosition.Y][newPosition.X] != 0 && distances[newPosition.Y][newPosition.X] > (distances[actPosition.Y][actPosition.X] + 1) {
					continue
				}
				distances[newPosition.Y][newPosition.X] = distances[actPosition.Y][actPosition.X]+1;
				frontier = append(frontier, newPosition)
			}
		}
	}
	return distances
}

func (p Day12) PartA(lines []string) any {
	var game [][]rune
	var startPosition, endPosition Position
	for y, line := range lines{
		if line == "" {
			continue
		}
		game = append(game, make([]rune, 0))
		for x, char := range line {
			game[y] = append(game[y], char)
			if char == 'S'{
				startPosition = *NewPosition(x, y)
				game[y][x] = 'a'
			}
			if char == 'E'{
				endPosition = *NewPosition(x, y)
				game[y][x] = 'z'
			}
		}
	}
	distances := Search(startPosition, endPosition, game)
	return distances[endPosition.Y][endPosition.X]
}

func (p Day12) PartB(lines []string) any {
	var game [][]rune
	var endPosition Position
	for y, line := range lines{
		if line == "" {
			continue
		}
		game = append(game, make([]rune, 0))
		for x, char := range line {
			game[y] = append(game[y], char)
			if char == 'S'{
				game[y][x] = 'a'
			}
			if char == 'E'{
				endPosition = *NewPosition(x, y)
				game[y][x] = 'z'
			}
		}
	}
	var ranges map[int]Position = make(map[int]Position)
	for i, line := range game {
		for j := range line {
			position := *NewPosition(j, i)
			if game[i][j] == 'a'{
				distances := Search(*NewPosition(j, i), endPosition, game)
				ranges[distances[endPosition.Y][endPosition.X]] = position
			}
		} 
	}
	keys := make([]int, 0, len(ranges))
	for k := range ranges {
		if k != 0{
			keys = append(keys, k)
		}
	}
	sort.Ints(keys)
	return keys[0]
}