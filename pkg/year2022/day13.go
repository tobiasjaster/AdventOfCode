// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"encoding/json"
	"strings"
	"fmt"
)

type Day13 struct{}

type Mode int

const (
	NotFinished Mode = 0
	Right Mode = 1
	False Mode = 2
)

func compare(left []byte, right []byte) (Mode, error){
	var leftSlice []*json.RawMessage
	var leftNr int
	var leftOperation string
	var rightSlice []*json.RawMessage
	var rightNr int
	var rightOperation string
	var err error
	err = json.Unmarshal(left, &leftNr)
	if err != nil {
		err = json.Unmarshal(left, &leftSlice)
		if err != nil {
			leftOperation = ""
			return NotFinished, nil
		}else {
			leftOperation = "List"
		}
	} else {
		leftOperation = "Nr"
	}
	err = json.Unmarshal(right, &rightNr)
	if err != nil {
		err = json.Unmarshal(right, &rightSlice)
		if err != nil {
			rightOperation = ""
			return NotFinished, nil
		}else {
			rightOperation = "List"
		}
	} else {
		rightOperation = "Nr"
	}
	mode := NotFinished
	if leftOperation == "List" && rightOperation == "List" {
		for i := range leftSlice {
			if i>=len(rightSlice){
				return False, nil
			}
			mode, _ = compare(*leftSlice[i], *rightSlice[i])
			if mode != NotFinished {
				return mode, nil
			}
		}
		if mode == NotFinished && len(leftSlice)<len(rightSlice) {
			return Right, nil
		}
	} else if leftOperation == "Nr" && rightOperation == "Nr" {
		if leftNr < rightNr {
			return Right, nil
		} else if leftNr > rightNr {
			return False, nil
		}
		return NotFinished, nil
	} else if leftOperation == "List" && rightOperation == "Nr" {
		rightBytes := []byte(fmt.Sprintf("[%d]", rightNr))
		return compare(left, rightBytes)
	} else if leftOperation == "Nr" && rightOperation == "List" {
		leftBytes := []byte(fmt.Sprintf("[%d]", leftNr))
		return compare(leftBytes, right)
	}
	return NotFinished, nil
}

func sortPackets(packets [][]byte) [][]byte {
	var finish bool
	for {
		finish = true
		for i:=1;i<len(packets);i++ {
			mode, _ := compare(packets[i-1], packets[i])
			if mode == False {
				packet := packets[i-1]
				packets[i-1] = packets[i]
				packets[i] = packet
				finish = false
			}
		}
		if finish {
			break
		}
	}
	return packets
}

func (p Day13) PartA(lines []string) any {
	var rightOrderList []int
	for pair := 1; pair<=len(lines)/3; pair++ {
		left := []byte(strings.ReplaceAll(lines[pair*3-3],"\r", ""))
		right := []byte(strings.ReplaceAll(lines[pair*3-2],"\r", ""))
		mode, _ := compare(left, right)
		if mode == Right {
			rightOrderList = append(rightOrderList, pair)
		}
	}
	var sum int
	for _, number := range rightOrderList {
		sum += number
	}
	return sum
}

func (p Day13) PartB(lines []string) any {
	var packets [][]byte
	packets = append(packets, []byte("[[2]]"))
	packets = append(packets, []byte("[[6]]"))
	for pair := 1; pair<=len(lines)/3; pair++ {
		packets = append(packets, []byte(strings.ReplaceAll(lines[pair*3-3],"\r", "")))
		packets = append(packets, []byte(strings.ReplaceAll(lines[pair*3-2],"\r", "")))
	}

	packets = sortPackets(packets)
	var sum int = 1
	for i, packet := range packets {
		if string(packet) == string([]byte("[[2]]")) || string(packet) == string([]byte("[[6]]")) {
			sum *= i+1
		}
	}
	return sum
}
