// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"fmt"
	"strconv"
	"sort"
)
type Day08 struct{}

func parseMap (lines []string) [][]int {
	var readContent [][]int = make([][]int, len(lines)-1)
	for i, row := range lines {
		if row == "" {continue}
		readContent[i] = make([]int, 0)
		for _, column := range row {
			hight, _ := strconv.Atoi(string(column))
			readContent[i] = append(readContent[i], hight)
		}
	}
	return readContent
}

func (p Day08) PartA(lines []string) any {
	var readContent [][]int = make([][]int, len(lines)-1)
	var actualHight int
	var visible [][]int = make([][]int, len(lines)-1)
	
	readContent = parseMap(lines)
	for i, row := range readContent {
		visible[i] = make([]int, len(row))
	}
	for i:=0;i<4;i++ {
		actualHight = -1
		for j, line := range readContent {
			actualHight = -1
			for k, hight := range line {
				if hight>actualHight {
					visible[j][k] = 1
					actualHight = hight
					if actualHight == 9{break}
				}
			}
			actualHight = -1
			for k := len(line)-1; k>=0; k-- {
				if line[k]>actualHight {
					visible[j][k] = 1
					actualHight = line[k]
					if actualHight == 9{break}
				}
			}
		}
		for k := len(readContent[0])-1; k>=0; k--{
			actualHight = -1
			for j, _ := range readContent {
				if readContent[j][k]>actualHight {
					visible[j][k] = 1
					actualHight = readContent[j][k]
					if actualHight == 9{break}
				}
			}
			actualHight = -1
			for j := len(readContent)-1; j>=0; j-- {
				if readContent[j][k]>actualHight {
					visible[j][k] = 1
					actualHight = readContent[j][k]
					if actualHight == 9{break}
				}
			}
		}
	}
	var count int
	for _, line := range visible {
		for _, tree := range line {
			if tree == 1 { count++ }
		}
	}
	fmt.Println(visible)
	return count
}

func (p Day08) PartB(lines []string) any {
	var readContent [][]int = parseMap(lines)
	var maxCounter []int
	for j, line := range readContent {
		for k, point := range line {
			maxCount := 1
			count := 0
			for l:=k-1;l>=0;l--{
				if readContent[j][l]<point { 
					count++
				} else {
					count++
					break
				}
			}
			if count > 0 {
				maxCount *= count
			}
			count = 0
			for l:=k+1;l<len(line);l++{
				if readContent[j][l] < point {
					count++
				} else {
					count++
					break
				}
			}
			if count > 0 {
				maxCount *= count
			}
			count = 0
			for l:=j-1;l>=0;l--{
				if readContent[l][k]<point { 
					count++
				} else {
					count++
					break
				}
			}
			if count > 0 {
				maxCount *= count
			}
			count = 0
			for l:=j+1;l<len(readContent);l++{
				if readContent[l][k]<point { 
					count++
				} else {
					break
				}
			}
			if count > 0 {
				maxCount *= count
			}
			maxCounter = append(maxCounter, maxCount)
		}
	}
	sort.Sort(sort.Reverse(sort.IntSlice(maxCounter)))
	return maxCounter[0]
}
