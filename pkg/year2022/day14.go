// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"fmt"
	"strings"
)

type Day14 struct{}

type Point struct {
	X int
	Y int
}

var maxY int

func NewPoint(x int, y int) *Point {
	p := new(Point)
	p.X = x
	p.Y = y
	return p
}

func NewPointString(str string) *Point {
	p := new(Point)
	fmt.Sscanf(str, "%d,%d", &p.X, &p.Y)
	return p
}

func createMap(lines []string, offset int) [][]string {
	var rocksPoints [][]Point
	for _, line := range lines {
		if line == "" {continue}
		pointStrings := strings.Split(line, " -> ")
		var points []Point
		for _, pointString := range pointStrings {
			point := *NewPointString(pointString)
			if point.Y > maxY {
				maxY = point.Y
			}
			points = append(points, point)

		}
		rocksPoints = append(rocksPoints, points)
	}
	maxY += offset
	var rockMap [][]string = make([][]string, maxY+1)
	for i:=0;i<(maxY+1);i++{
		rockMap[i] = make([]string, 1001)
	}
	fmt.Println(maxY)
	for _, rockPoints := range rocksPoints {
		for i:=1;i<len(rockPoints);i++{
			if rockPoints[i-1].X < rockPoints[i].X {
				for j:=0;j<=(rockPoints[i].X - rockPoints[i-1].X); j++{
					rockMap[rockPoints[i-1].Y][rockPoints[i-1].X+j] = "#"
				}
			} else if rockPoints[i-1].X > rockPoints[i].X {
				for j:=0;j<=(rockPoints[i-1].X - rockPoints[i].X); j++{
					rockMap[rockPoints[i-1].Y][rockPoints[i-1].X-j] = "#"
				}
			} else if rockPoints[i-1].Y < rockPoints[i].Y {
				for j:=0;j<=(rockPoints[i].Y - rockPoints[i-1].Y); j++{
					rockMap[rockPoints[i-1].Y+j][rockPoints[i-1].X] = "#"
				}
			} else if rockPoints[i-1].Y > rockPoints[i].Y {
				for j:=0;j<=(rockPoints[i-1].Y - rockPoints[i].Y); j++{
					rockMap[rockPoints[i-1].Y-j][rockPoints[i-1].X] = "#"
				}
			}
		}
	}
	return rockMap
}

func sandFallA(rockMap [][]string) ([][]string, int) {
	var finished bool = false
	var count int
	fmt.Println(maxY)
	for { //for i:=0;i<722;i++ {
		count += 1
		if finished {
			break
		}
		// fmt.Println(count)
		sand := NewPoint(500, 0)
		for {
			if sand.Y == maxY {
				finished = true
				break
			}
			if rockMap[sand.Y+1][sand.X] == "" {
				sand.Y += 1
				continue
			} else if rockMap[sand.Y+1][sand.X-1] == "" { // else if rockMap[sand.Y][sand.X-1] == "" && rockMap[sand.Y+1][sand.X-1] == "" {
				sand.Y += 1
				sand.X -= 1
				continue
			} else if rockMap[sand.Y+1][sand.X+1] == "" { // else if rockMap[sand.Y][sand.X+1] == "" && rockMap[sand.Y+1][sand.X+1] == "" {
				sand.Y += 1
				sand.X += 1
				continue
			} else {
				rockMap[sand.Y][sand.X] = "o"
				break
			}
		}
	}
	return rockMap, count
}

func sandFallB(rockMap [][]string) ([][]string, int) {
	var finished bool = false
	var count int
	fmt.Println(maxY)
	for { //for i:=0;i<722;i++ {
		if finished {
			break
		}
		count += 1
		// fmt.Println(count)
		sand := NewPoint(500, 0)
		for {
			if sand.Y == maxY-1 {
				rockMap[sand.Y][sand.X] = "o"
				break
			} else if rockMap[sand.Y+1][sand.X] == "" {
				sand.Y += 1
				continue
			} else if rockMap[sand.Y+1][sand.X-1] == "" { // else if rockMap[sand.Y][sand.X-1] == "" && rockMap[sand.Y+1][sand.X-1] == "" {
				sand.Y += 1
				sand.X -= 1
				continue
			} else if rockMap[sand.Y+1][sand.X+1] == "" { // else if rockMap[sand.Y][sand.X+1] == "" && rockMap[sand.Y+1][sand.X+1] == "" {
				sand.Y += 1
				sand.X += 1
				continue
			} else {
				rockMap[sand.Y][sand.X] = "o"
				if sand.Y == 0 {
					finished = true
				}
				break
			}
		}
	}
	return rockMap, count
}

func (p Day14) PartA(lines []string) any {
	rockMap := createMap(lines, 0)
	_, count := sandFallA(rockMap)
	// for _, rockline:=range newrockMap{
	// 	for _, char := range rockline {
	// 		if char == "" {
	// 			fmt.Print(".")
	// 		}else{
	// 			fmt.Print(char)
	// 		}
	// 	}
	// 	fmt.Println()
	// }
	return count
}

func (p Day14) PartB(lines []string) any {
	rockMap := createMap(lines, 2)
	_, count := sandFallB(rockMap)
	// for _, rockline:=range newrockMap{
	// 	for _, char := range rockline {
	// 		if char == "" {
	// 			fmt.Print(".")
	// 		}else{
	// 			fmt.Print(char)
	// 		}
	// 	}
	// 	fmt.Println()
	// }
	return count
}
