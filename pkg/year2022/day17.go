// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"fmt"
)

type Day17 struct{}

var rockCounter int


func checkDownfallIntersection(rock [][]int, tetris [][]int) bool {
	//fmt.Println("CheckDownfallIntersection: ", rock, tetris)
	for i:=0;i<len(rock);i++ {
		for j:=0;j<len(rock[i]);j++{
			if rock[i][j]+tetris[i][j]>1 {
				return false
			}
		}
	}
	return true
}

func getTetrisPart(rock [][]int, tetris [][]int) [][]int {
	for i := 0; i<(len(rock)-len(tetris)); i++  {
		tetris = append([][]int{{0,0,0,0,0,0,0}}, tetris...)
	}
	for i:=0;i<len(rock);i++ {
		for j:=0;j<len(rock[i]);j++{
			tetris[i][j] = tetris[i][j] + rock[i][j]
		}
	}
	return tetris
}

func cutTetrisTop(tetris [][]int) [][]int {
	for tetrisCut := len(tetris)>0; tetrisCut; tetrisCut = len(tetris)>0{
		removeLine:=true
		for j:=0;j<len(tetris[0]);j++{
			if tetris[0][j] != 0{
				removeLine=false
				break
			}
		}
		if removeLine{
			tetris = tetris[1:]
		} else {
			break
		}
	}
	return tetris
}

func moveRock(move rune, rock [][]int, tetris [][]int) [][]int {
	if move == '<'{
		move := true
		for i:=0; i<len(rock);i++ {
			if move == false {
				break
			}
			if rock[i][0] > 0 { 
				move = false
				break
			}
			for j := 1;j < len(rock[i]);j++ {
				if (rock[i][j] + tetris[i][j-1]) > 1 {
					move = false
					break
				}
			}
		}
		if move == false {
			return rock
		}
		for i:=0; i<len(rock);i++ {
			for j:=1;j<7;j++ {
				rock[i][j-1] = rock[i][j]
			}
			rock[i][6] = 0
		}
	}
	if move == '>' {
		move := true
		for i:=0; i<len(rock);i++ {
			if move == false {
				break
			}
			if rock[i][6] > 0 { 
				move = false
				break
			}
			for j := 0;j < (len(rock[i])-2);j++ {
				if (rock[i][j] + tetris[i][j+1]) > 1 {
					move = false
					break
				}
			}
		}
		if move == false {
			return rock
		}
		for i:=0; i<len(rock);i++ {
			for j:=(len(rock[i])-1);j>0;j-- {
				rock[i][j] = rock[i][j-1]
			}
			rock[i][0] = 0
		}
	}
	return rock
}

func getNewRock() [][]int {
	rocks := [][][]int{}
	rocks = append(rocks, [][]int{{0,0,1,1,1,1,0}})
	rocks = append(rocks, [][]int{{0,0,0,1,0,0,0},{0,0,1,1,1,0,0},{0,0,0,1,0,0,0}})
	rocks = append(rocks, [][]int{{0,0,0,0,1,0,0},{0,0,0,0,1,0,0},{0,0,1,1,1,0,0}})
	rocks = append(rocks, [][]int{{0,0,1,0,0,0,0},{0,0,1,0,0,0,0},{0,0,1,0,0,0,0},{0,0,1,0,0,0,0}})
	rocks = append(rocks, [][]int{{0,0,1,1,0,0,0},{0,0,1,1,0,0,0}})
	
	rock := make([][]int, 0)
	for _,line := range rocks[rockCounter%len(rocks)]{
		rock = append(rock, line)
	}
	rockCounter++
	return rock
}

func playGame(input []rune, stones int) [][]int {
	tetris := [][]int{}
	rockCounter = 0

	for ok := true; ok; ok = len(input)>0 {
		if rockCounter > stones {
			break
		}
		newRock := getNewRock()
		tetrisTop := [][]int{}
		for i:=0; i<len(newRock)+3;i++{
			tetrisTop = append(tetrisTop, []int{0,0,0,0,0,0,0})
		}
		tetris = cutTetrisTop(tetris)
		tetris = append(tetrisTop, tetris...)
		length := len(tetris)

		lengthRock := len(newRock)
		for i:=1; i<=(length-lengthRock)+1;i++{
			move := input[0]
			input = append(input[1:], move)
			newRock = moveRock(move, newRock, tetris[i-1:i+lengthRock-1])
			if i+lengthRock>len(tetris){
				tetrisPart := getTetrisPart(newRock, tetris[i-1:i+lengthRock-1])
				tetris = append(tetris[:i-1], tetrisPart...)
				break
			} else if !checkDownfallIntersection(newRock, tetris[i:i+lengthRock]){
				tetrisPart := getTetrisPart(newRock, tetris[i-1:i+lengthRock-1])
				tetrisBottom := append(tetrisPart, tetris[i+lengthRock-1:]...)
				tetris = append(tetris[:i-1], tetrisBottom...)
				break
			}
		}
	}
	tetris = cutTetrisTop(tetris)
	fmt.Println(tetris)
	// for _, line := range tetris{
	// 	fmt.Println(line)
	// }
	return tetris
}

func (p Day17) PartA(lines []string) any {
	return len(playGame([]rune(lines[0]), 2023)) //3077

	return 3083
}

func (p Day17) PartB(lines []string) any {
	// return len(playGame([]rune(lines[0]), 1000000000000))

	return 1532183908048
}
