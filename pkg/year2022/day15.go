// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"fmt"
	"math"
	"sort"
)

type Day15 struct{}

type XCoverage struct {
	MinX int
	MaxX int
}

func NewXCoverage(minX int, minY int) *XCoverage {
	newXCoverage := *new(XCoverage)
	newXCoverage.MinX = minX
	newXCoverage.MaxX = minY
	return &newXCoverage
}

type XCoverages struct {
	List []XCoverage
}

func (r *XCoverages)addXCoverage(newCoverage XCoverage) {
	newList := make([]XCoverage, 0)
	for _, oldCoverage := range r.List {
		if (newCoverage.MinX <= oldCoverage.MinX && oldCoverage.MinX <= newCoverage.MaxX) || 
			(oldCoverage.MinX <= newCoverage.MinX && newCoverage.MinX <= oldCoverage.MaxX) || 
			(newCoverage.MaxX + 1 == oldCoverage.MinX) || (oldCoverage.MaxX + 1 == newCoverage.MinX){
				newCoverage.MinX = int(math.Min(float64(newCoverage.MinX), float64(oldCoverage.MinX)))
				newCoverage.MaxX = int(math.Max(float64(newCoverage.MaxX), float64(oldCoverage.MaxX)))
		} else {
			newList = append(newList, oldCoverage)
		}
	}
	newList = append(newList, newCoverage)
	r.List = newList
}

type Sensor struct {
	X int
	Y int
}

type Beacon struct {
	X int
	Y int
}

type SensorBeacon struct {
	S Sensor
	B Beacon
	Distance int
}

func (sb *SensorBeacon) getDistance() int {
	return int(math.Abs(float64(sb.S.X)-float64(sb.B.X))) + int(math.Abs(float64(sb.S.Y)-float64(sb.B.Y)))
}


func (sb *SensorBeacon) blocksRows(rowNr int) []int {
	var columns []int
	if rowNr > sb.S.Y && rowNr-sb.S.Y < sb.getDistance() {
		blockedLength := sb.getDistance()-(rowNr-sb.S.Y)+1
		for i:=0; i<blockedLength; i++ {
			if i==0 {
				columns = append(columns, sb.S.X) 
			} else {
				columns = append(columns, sb.S.X+i) 
				columns = append(columns, sb.S.X-i) 
			}
		}
	}
	if rowNr < sb.S.Y && sb.S.Y-rowNr < sb.getDistance() {
		blockedLength := sb.getDistance()-(sb.S.Y-rowNr)+1
		for i:=0; i<blockedLength; i++ {
			if i==0 {
				columns = append(columns, sb.S.X) 
			} else {
				columns = append(columns, sb.S.X+i) 
				columns = append(columns, sb.S.X-i) 
			}
		}
	}
	sort.Ints(columns)
	// fmt.Println(sb.S, sb.B, sb.getDistance(), len(columns))
	return columns
}

func parseLine(lines []string) []SensorBeacon {
	sensorBeacons := make([]SensorBeacon, 0)
	for _, line := range lines {
		sb := new(SensorBeacon)
		fmt.Sscanf(line, "Sensor at x=%d, y=%d: closest beacon is at x=%d, y=%d", &sb.S.X, &sb.S.Y, &sb.B.X, &sb.B.Y)
		sb.Distance = sb.getDistance()
		sensorBeacons = append(sensorBeacons, *sb)
	}
	return sensorBeacons
}

func (p Day15) PartA(lines []string) any {
	row := 2000000
	var row2000000 map[int][]Sensor = make(map[int][]Sensor, 0)
	var rows []int
	sbs := parseLine(lines)
	for _, sb := range sbs {
		blockedRows := sb.blocksRows(row)
		for _, row := range blockedRows {
			row2000000[row] = append(row2000000[row], sb.S)
		} 
	}
	var skip bool
	for k, _ := range row2000000 {
		skip = false
		for _, sb := range sbs {
			if sb.B.Y == row && sb.B.X == k{
				skip = true
				break
			}
		}
		if skip {
			continue
		}
		rows = append(rows, k)
	}
	sort.Ints(rows)
	return len(rows)
}

func (p Day15) PartB(lines []string) any {
	rowRange := []int{0,4000000}
	yxCoverages := map[int]XCoverages{}
	sbs := parseLine(lines)
	for _, sb := range sbs {
		for i := -sb.Distance; i <= sb.Distance; i++ { // Add X-Coverages to each
			if rowRange[0] < (sb.S.Y + i) && (sb.S.Y + i) < rowRange[1] {
				y := (sb.S.Y + i)
				coverageIndex := yxCoverages[y]
				coverageIndex.addXCoverage(*NewXCoverage((sb.S.X - sb.Distance + int(math.Abs(float64(i)))), (sb.S.X + sb.Distance - int(math.Abs(float64(i))))))
				yxCoverages[y] = coverageIndex
			}
		}
	}
	var result int
	for y, coverage := range yxCoverages {
		if len(coverage.List) == 2{
			x := int(math.Min(float64(coverage.List[0].MaxX), float64(coverage.List[1].MaxX)))+1
			result = rowRange[1]*x+y
		}
	}
	return result
}
