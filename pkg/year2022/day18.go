// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"fmt"
	"math"
)

type Day18 struct{}

type Position18 struct {
	X int
	Y int
	Z int
}

type Cube struct {
	Pos Position18
	Connected []*Cube 
}

type Air struct {
	Pos Position18
	Distance int
	Checked bool 
}

func distance(pos1 Position18, pos2 Position18) int {
	return int(math.Abs(float64(pos1.X)-float64(pos2.X)))+int(math.Abs(float64(pos1.Y)-float64(pos2.Y)))+int(math.Abs(float64(pos1.Z)-float64(pos2.Z)))
}

func readCubes(lines []string) map[Position18]Cube {
	cubes := make(map[Position18]Cube)
	for _, line := range lines {
		if line == "" {continue}
		cube := *new(Cube)
		fmt.Sscanf(line, "%d,%d,%d", &cube.Pos.X, &cube.Pos.Y, &cube.Pos.Z)
		cubes[cube.Pos] = cube
	}
	return cubes
}

func getNextAirs(pos Position18, cubes map[Position18]Cube) map[Position18]Air{
	airs := make(map[Position18]Air)
	new_pos := pos
	new_pos.X = new_pos.X - 1
	_, err := cubes[new_pos]
	if !err {
		airs[new_pos] = Air{Pos: new_pos, Checked: false}
	}
	new_pos = pos
	new_pos.X = new_pos.X + 1
	_, err = cubes[new_pos]
	if !err {
		airs[new_pos] = Air{Pos: new_pos, Checked: false}
	}
	new_pos = pos
	new_pos.Y = new_pos.Y - 1
	_, err = cubes[new_pos]
	if !err {
		airs[new_pos] = Air{Pos: new_pos, Checked: false}
	}
	new_pos = pos
	new_pos.Y = new_pos.Y + 1
	_, err = cubes[new_pos]
	if !err {
		airs[new_pos] = Air{Pos: new_pos, Checked: false}
	}
	new_pos = pos
	new_pos.Z = new_pos.Z - 1
	_, err = cubes[new_pos]
	if !err {
		airs[new_pos] = Air{Pos: new_pos, Checked: false}
	}
	new_pos = pos
	new_pos.Z = new_pos.Z + 1
	_, err = cubes[new_pos]
	if !err {
		airs[new_pos] = Air{Pos: new_pos, Checked: false}
	}
	return airs
}

func getDistanceMap(cubes map[Position18]Cube, maxPos Position18) map[Position18]Air {
	airs := make(map[Position18]Air)
	start := Position18{X: 0, Y: 0, Z: 0}
	airs[start] = Air{Pos: start, Checked: false, Distance: 0}
	queue := make([]Position18,0)
	queue = append(queue, start)
	for ok := true; ok; ok = len(queue)>0 {
		actPos := queue[len(queue)-1]
		queue = queue[:len(queue)-1]
		if airs[actPos].Checked { continue }
		air := airs[actPos]
		air.Checked = true
		airs[actPos] = air

		newAirs := getNextAirs(actPos, cubes)
		for newPos, newAir := range newAirs {
			if newPos.X>maxPos.X || newPos.Y>maxPos.Y || newPos.Z>maxPos.Z { continue }
			if newPos.X<0 || newPos.Y<0 || newPos.Z<0 { continue }
			_, err := airs[newPos]
			if err { continue }
			newAir.Distance = air.Distance + 1
			airs[newPos] = newAir
			queue = append(queue, newPos)
		}
	}
	return airs
}

func (p Day18) PartA(lines []string) any {
	cubes := readCubes(lines)
	for pos, cube := range cubes {
		for _, cubeConn := range cubes {
			if distance(cube.Pos, cubeConn.Pos) == 1{
				connected := cube.Connected
				connected = append(connected, &cubeConn)
				cube.Connected = connected
				cubes[pos] = cube
			}
		}
	}
	countVisible := 0
	for _, cube := range cubes {
		countVisible += 6-len(cube.Connected)
	}
	return countVisible
}

func (p Day18) PartB(lines []string) any {
	cubes := readCubes(lines)
	maxPosition := Position18{X:0, Y:0, Z:0}
	for pos, _ := range cubes {
		if pos.X+1>maxPosition.X{
			maxPosition.X = pos.X+1
		}
		if pos.Y+1>maxPosition.Y{
			maxPosition.Y = pos.Y+1
		}
		if pos.Z+1>maxPosition.Z{
			maxPosition.Z = pos.Z+1
		}
		// for _, cubeConn := range cubes {
		// 	if distance(cube, cubeConn) == 1{
		// 		connected := cube.Connected
		// 		connected = append(connected, &cubeConn)
		// 		cube.Connected = connected
		// 		cubes[pos] = cube
		// 	}
		// }
	}
	airs := getDistanceMap(cubes, maxPosition)
	fmt.Println(airs)
	countAirFields := 0
	for pos, _ := range cubes {
		for _, air := range airs {
			if distance(pos, air.Pos) == 1{
				countAirFields++
			}
		}
	}
	return countAirFields
}
