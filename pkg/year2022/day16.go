// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"fmt"
	"strings"
	// "sort"
)

type Day16 struct{}

type Valve struct {
	ID string
	FR int
	Connected []string
}

type ValvePressure struct {
	ID string
	FR int
	Pressure int
	ShortPath map[string]int
}

type Valves struct {
	V map[string]Valve
}

type ShortPath struct {
	Position string
	LastPosition string
	Minutes int
}

type MaxPressure struct {
	Position string
	LastPosition string
	Minutes int
	valvesMap map[string]ValvePressure
	Pressure int
	Moves []string
}

type MaxPressureB struct {
	PositionA string
	MinutesA int
	PositionB string
	MinutesB int
	valvesMap map[string]ValvePressure
	Pressure int
	Moves map[string][]string
}

func NewValve(id string, fr int, ids []string) *Valve {
	v := new(Valve)
	v.ID = id
	v.FR = fr
	v.Connected = ids
	return v
}

func NewValves() *Valves {
	v := new(Valves)
	v.V = make(map[string]Valve)
	return v
}

func parseLines(lines []string) Valves {
	var valves Valves = *NewValves()
	for _, line := range lines {
		if line == "" { continue }
		line = strings.ReplaceAll(line, ", ", ",")
		lineSplit := strings.Split(line, " ")
		var id string
		var fr int
		ids := lineSplit[len(lineSplit)-1]
		fmt.Sscanf(line, "Valve %s has flow rate=%d; tunnels lead to", &id, &fr)
		valves.V[id] = *NewValve(id, fr, strings.Split(ids, ","))
	}
	return valves
}

func shortestMinutes(valves Valves, start string, end string) int {
	shortPath := *new(ShortPath)
	shortPath.Minutes = 0
	shortPath.Position = start
	var frontier []ShortPath
	frontier = append(frontier, shortPath)
	var actPosition ShortPath
	var shortestMinutes int = 0
	for ok := true; ok; ok = len(frontier)>0 {
		actPosition = frontier[0]
		frontier = frontier[1:]
		if shortestMinutes != 0 && actPosition.Minutes > shortestMinutes { continue }
		if actPosition.Position == end {
			if shortestMinutes == 0 || shortestMinutes > actPosition.Minutes{
				shortestMinutes = actPosition.Minutes
			}
			continue
		}
		for _, id := range valves.V[actPosition.Position].Connected {
			if id == actPosition.LastPosition {continue}
			newShortPath := *new(ShortPath)
			newShortPath.LastPosition = actPosition.Position
			newShortPath.Minutes = actPosition.Minutes + 1
			newShortPath.Position = id
			frontier = append(frontier, newShortPath)
		}
	}
	return shortestMinutes
}

func mostPressure(maxPressure MaxPressure, minutes int) int {
	var pressure int
	var frontier []MaxPressure
	frontier = append(frontier, maxPressure)
	var count int64
	for ok := true; ok; ok = len(frontier)>0 {
		count++
		actPosition := frontier[len(frontier)-1]
		frontier = frontier[:len(frontier)-1]
		openPosition := 0
		restPressure := 0
		for _, v := range actPosition.valvesMap {
			if v.Pressure == -1 {
				openPosition++
				restPressure += v.FR
			}
		}
		if actPosition.Minutes >= minutes || openPosition == 0{
			if pressure < actPosition.Pressure{
				pressure = actPosition.Pressure
			}
			continue
		}
		if pressure>(actPosition.Pressure + (minutes-actPosition.Minutes)*restPressure) {
			continue
		}
		if actPosition.valvesMap[actPosition.Position].Pressure == -1{
			nextMaxPressure := *new(MaxPressure)
			nextMaxPressure.Minutes = actPosition.Minutes+1
			nextMaxPressure.Position = actPosition.Position
			nextMaxPressure.LastPosition = ""
			nextMaxPressure.valvesMap = actPosition.valvesMap
			nextMaxPressure.Moves = actPosition.Moves
			pressure := (minutes-actPosition.Minutes)*actPosition.valvesMap[actPosition.Position].FR
			valve := actPosition.valvesMap[actPosition.Position]
			valve.Pressure = pressure
			nextMaxPressure.valvesMap[actPosition.Position] = valve
			nextMaxPressure.Pressure = actPosition.Pressure + pressure
			frontier = append(frontier, nextMaxPressure)
		}
		for dest, length := range actPosition.valvesMap[actPosition.Position].ShortPath {
			if actPosition.valvesMap[dest].Pressure != -1 { continue } 
			nextMaxPressure := *new(MaxPressure)
			nextMaxPressure.Minutes = actPosition.Minutes+length
			nextMaxPressure.Position = dest
			nextMaxPressure.LastPosition = actPosition.Position
			nextMaxPressure.Pressure = actPosition.Pressure
			nextMaxPressure.valvesMap = make(map[string]ValvePressure)
			nextMaxPressure.Moves = []string{}
			for _, move := range actPosition.Moves {
				nextMaxPressure.Moves = append(nextMaxPressure.Moves, move)
			}
			nextMaxPressure.Moves = append(nextMaxPressure.Moves, dest)
			
			for k,v := range actPosition.valvesMap {
				newValvePressure := *new(ValvePressure)
				newValvePressure.FR = v.FR
				newValvePressure.ID = v.ID
				newValvePressure.Pressure = v.Pressure
				newValvePressure.ShortPath = v.ShortPath
				nextMaxPressure.valvesMap[k] = newValvePressure
			}
			frontier = append(frontier, nextMaxPressure)
		}
	}
	return pressure
}

func mostPressureB(maxPressure MaxPressureB, minutes int) int {
	var pressure int
	var frontier []MaxPressureB
	frontier = append(frontier, maxPressure)
	var count int64
	for ok := true; ok; ok = len(frontier)>0 {
		count++
		actPosition := frontier[len(frontier)-1]
		frontier = frontier[:len(frontier)-1]
		openPosition := 0
		restPressure := 0
		for _, v := range actPosition.valvesMap {
			if v.Pressure == -1 {
				openPosition++
				restPressure += v.FR
			}
		}
		if (actPosition.MinutesA >= minutes && actPosition.MinutesB >= minutes) || openPosition == 0{
			if pressure < actPosition.Pressure{
				pressure = actPosition.Pressure
			}
			continue
		}
		var maxRestMin int
		if actPosition.MinutesA<actPosition.MinutesB {
			maxRestMin = actPosition.MinutesA
		}else {
			maxRestMin = actPosition.MinutesB
		}
		if pressure>(actPosition.Pressure + (minutes-maxRestMin)*restPressure) {
			continue
		}
		if actPosition.MinutesA <= actPosition.MinutesB {
			for dest, length := range actPosition.valvesMap[actPosition.PositionA].ShortPath {
				if actPosition.valvesMap[dest].Pressure != -1 { continue } 
				nextMaxPressure := *new(MaxPressureB)
				nextMaxPressure.MinutesA = actPosition.MinutesA+1+length
				nextMaxPressure.PositionA = dest
				nextMaxPressure.MinutesB = actPosition.MinutesB
				nextMaxPressure.PositionB = actPosition.PositionB
				nextMaxPressure.Pressure = actPosition.Pressure
				nextMaxPressure.Moves = make(map[string][]string)
				for _,move := range actPosition.Moves["B"] {
					nextMaxPressure.Moves["B"] = append(nextMaxPressure.Moves["B"], move)
				}
				for _,move := range actPosition.Moves["A"] {
					nextMaxPressure.Moves["A"] = append(nextMaxPressure.Moves["A"], move)
				}
				if nextMaxPressure.MinutesA<minutes{
					nextMaxPressure.Moves["A"] = append(nextMaxPressure.Moves["A"], dest)
				}

				nextMaxPressure.valvesMap = make(map[string]ValvePressure)
				for k,v := range actPosition.valvesMap {
					newValvePressure := *new(ValvePressure)
					newValvePressure.FR = v.FR
					newValvePressure.ID = v.ID
					newValvePressure.Pressure = v.Pressure
					newValvePressure.ShortPath = v.ShortPath
					nextMaxPressure.valvesMap[k] = newValvePressure
				}
				
				if nextMaxPressure.MinutesA<minutes{
					pressure := (minutes-(nextMaxPressure.MinutesA-1))*actPosition.valvesMap[dest].FR
					valve := nextMaxPressure.valvesMap[dest]
					valve.Pressure = pressure
					nextMaxPressure.valvesMap[dest] = valve
					nextMaxPressure.Pressure = actPosition.Pressure + pressure
				}
				frontier = append(frontier, nextMaxPressure)
			}
		} else {
			for dest, length := range actPosition.valvesMap[actPosition.PositionB].ShortPath {
				if actPosition.valvesMap[dest].Pressure != -1 { continue }
				nextMaxPressure := *new(MaxPressureB)
				nextMaxPressure.MinutesA = actPosition.MinutesA
				nextMaxPressure.PositionA = actPosition.PositionA
				nextMaxPressure.MinutesB = actPosition.MinutesB+1+length
				nextMaxPressure.PositionB = dest
				nextMaxPressure.Pressure = actPosition.Pressure
				nextMaxPressure.Moves = make(map[string][]string)
				for _,move := range actPosition.Moves["B"] {
					nextMaxPressure.Moves["B"] = append(nextMaxPressure.Moves["B"], move)
				}
				for _,move := range actPosition.Moves["A"] {
					nextMaxPressure.Moves["A"] = append(nextMaxPressure.Moves["A"], move)
				}
				
				if nextMaxPressure.MinutesA<minutes{
					nextMaxPressure.Moves["B"] = append(nextMaxPressure.Moves["B"], dest)
				}

				nextMaxPressure.valvesMap = make(map[string]ValvePressure)
				for k,v := range actPosition.valvesMap {
					newValvePressure := *new(ValvePressure)
					newValvePressure.FR = v.FR
					newValvePressure.ID = v.ID
					newValvePressure.Pressure = v.Pressure
					newValvePressure.ShortPath = v.ShortPath
					nextMaxPressure.valvesMap[k] = newValvePressure
				}
				
				if nextMaxPressure.MinutesB<minutes{
					pressure := (minutes-(nextMaxPressure.MinutesB-1))*actPosition.valvesMap[dest].FR
					valve := nextMaxPressure.valvesMap[dest]
					valve.Pressure = pressure
					nextMaxPressure.valvesMap[dest] = valve
					nextMaxPressure.Pressure = actPosition.Pressure + pressure
				}
				frontier = append(frontier, nextMaxPressure)
			}
		}
	}
	return pressure
}

func (p Day16) PartA(lines []string) any {
	valves := parseLines(lines)
	pressureValves := make([]string, 0)
	pressureValvesMap := make(map[string]ValvePressure)
	for _, valve := range valves.V {
		if valve.FR != 0 || valve.ID == "AA"{
			pressureValves = append(pressureValves, valve.ID)
		}
	}
	for i, pressure := range pressureValves {
		valvePressure := *new(ValvePressure)
		valvePressure.FR = valves.V[pressure].FR
		valvePressure.ID = pressure
		valvePressure.Pressure = -1
		valvePressure.ShortPath = make(map[string]int)
		for j:=0;j<len(pressureValves);j++{
			if j==i { continue }
			valvePressure.ShortPath[pressureValves[j]] = shortestMinutes(valves, pressure, pressureValves[j])
		}
		pressureValvesMap[pressure] = valvePressure
	}
	
	maxPressure := *new(MaxPressure)
	maxPressure.valvesMap = pressureValvesMap
	maxPressure.LastPosition = ""
	maxPressure.Minutes = 1
	maxPressure.Pressure = 0
	maxPressure.Position = "AA"
	maxPressure.Moves = []string{maxPressure.Position}

	count := mostPressure(maxPressure, 30)
	return count
}

func (p Day16) PartB(lines []string) any {
	valves := parseLines(lines)
	pressureValves := make([]string, 0)
	pressureValvesMap := make(map[string]ValvePressure)
	for _, valve := range valves.V {
		if valve.FR != 0 || valve.ID == "AA"{
			pressureValves = append(pressureValves, valve.ID)
		}
	}
	for i, pressure := range pressureValves {
		valvePressure := *new(ValvePressure)
		valvePressure.FR = valves.V[pressure].FR
		valvePressure.ID = pressure
		valvePressure.Pressure = -1
		valvePressure.ShortPath = make(map[string]int)
		for j:=0;j<len(pressureValves);j++{
			if j==i { continue }
			valvePressure.ShortPath[pressureValves[j]] = shortestMinutes(valves, pressure, pressureValves[j])
		}
		pressureValvesMap[pressure] = valvePressure
	}

	valve := pressureValvesMap["AA"]
	valve.Pressure = 0
	pressureValvesMap["AA"] = valve
	
	maxPressure := *new(MaxPressureB)
	maxPressure.valvesMap = pressureValvesMap
	maxPressure.MinutesA = 1
	maxPressure.PositionA = "AA"
	maxPressure.MinutesB = 1
	maxPressure.PositionB = "AA"
	maxPressure.Pressure = 0
	maxPressure.Moves = map[string][]string{}
	maxPressure.Moves["A"] = []string{maxPressure.PositionA}
	maxPressure.Moves["B"] = []string{maxPressure.PositionB}

	count := mostPressureB(maxPressure, 26)
	return count
}
