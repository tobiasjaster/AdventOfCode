// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"sort"
	"strconv"
	"strings"
)

type Day07 struct{}

type File struct {
	Name string
	Size int
}
type Dir struct {
	Name string
	Parent *Dir
	Dirs map[string]Dir
	Files map[string]File
}

type Information struct {
	Command string
	Content []string
}

func NewFile(name string, size int) *File {
	f := new(File)
	f.Name = name
	f.Size = size
	return f
}

func NewDir(name string, parent *Dir) *Dir {
	d := new(Dir)
	d.Name = name
	d.Parent = parent
	d.Dirs = make(map[string]Dir)
	d.Files = make(map[string]File)
	return d
}

func (d* Dir) addFile(file File) {
	d.Files[file.Name] = file
}

func (d* Dir) addDir(dir Dir){
	d.Dirs[dir.Name] = dir
}

func (d* Dir) getSum() int {
	sum := d.getFileSum() + d.getDirSum()
	return sum
}

func (d *Dir) getFileSum() int {
	var sum int
	for _, file := range d.Files{
		sum += file.Size
	}
	return sum
}

func (d *Dir) getDirSum() int {
	var sum int
	for _, dir := range d.Dirs {
		sum += dir.getSum()
	}
	return sum
}

func parseInput(lines []string) []Information{
	var commands []Information = make([]Information, 0)
	var information Information
	var newInformation bool = false
	for _, line := range lines {
		if line == "" && newInformation{
			commands = append(commands, information)
		}
		if strings.HasPrefix(line, "$ "){
			if newInformation{
				commands = append(commands, information)
			}
			information = *new(Information)
			information.Command = strings.ReplaceAll(line, "$ ", "")
			newInformation = true
		} else {
			information.Content = append(information.Content, line)
		}
	}
	return commands
}

func buildTree(commands []Information) Dir {
	var dir Dir = *NewDir("/", nil)
	var actualDir *Dir
	for _, command := range commands {
		if strings.HasPrefix(command.Command, "cd") {
			move := strings.Split(command.Command, " ")[1]
			if move == "/" {
				actualDir = &dir
			} else if move == ".." {
				actualDir = actualDir.Parent
			} else {
				for _, subdir := range actualDir.Dirs {
					if subdir.Name == move {
						actualDir = &subdir
						break
					}
				}
			}
		} else if command.Command == "ls" {
			for _, content := range command.Content {
				split := strings.Split(content, " ")
				if split[0] == "dir" {
					actualDir.addDir(*NewDir(split[1], actualDir))
				} else {
					size, _ := strconv.Atoi(split[0])
					actualDir.addFile(*NewFile(split[1],size))
				}
			}
		}
	}
	return dir
}

func (d *Dir)sumFolder100000() int {
	var sum int
	for _, subdir := range d.Dirs {
		if subdir.getSum() < 100000 {
			sum += subdir.getSum()
		}
		sum += subdir.sumFolder100000()
	}
	return sum
}

func (d *Dir)getFolderSizes() []int {
	var sizes []int = make([]int, 0)
	sizes = append(sizes, d.getSum())
	for _, subdir := range d.Dirs {
		otherSizes := subdir.getFolderSizes()
		for _, value := range otherSizes {
			sizes = append(sizes, value)
		}
	}
	return sizes
}

func (p Day07) PartA(lines []string) any {
	var commands []Information = parseInput(lines)
	dir := buildTree(commands)
	return dir.sumFolder100000()
}

func (p Day07) PartB(lines []string) any {
	var commands []Information = parseInput(lines)
	dir := buildTree(commands)
	searchSize := 30000000-(70000000-dir.getSum())
	folderSizes := dir.getFolderSizes()
	sort.Ints(folderSizes)
	for _, size := range folderSizes {
		if size>searchSize{
			return size
		}
	}
	return 0
}
