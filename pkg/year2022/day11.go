// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	//"fmt"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"math"
)

type Day11 struct{}

type Monkey struct{
	Items []int64
	OperationsCount int
	Operation string
	Test string
	Finish []string
}

func NewMonkey(lines []string) *Monkey{
	m := new(Monkey)
	itemsString := strings.ReplaceAll(lines[0], " ", "")
	itemsString = strings.Split(itemsString, ":")[1]
	itemsStringSplitted := strings.Split(itemsString, ",")
	for _, item := range itemsStringSplitted{
		m.Items = append(m.Items, int64(first(strconv.Atoi(item))))
	}
	m.Operation = strings.ReplaceAll(lines[1], "\r", "")
	m.Test = lines[2]
	m.Finish = lines[3:5]
	return m
}

func (m *Monkey) getDivisable() int {
	testString := strings.Split(m.Test, " ")
	return first(strconv.Atoi(testString[len(testString)-1]))
}

func (m* Monkey) operateItem(item int64, worryLevel int, allDivisable int64) (int, int64) {
	var new int64
	var add int64
	evalString := strings.Split(m.Operation, " ")
	if evalString[len(evalString)-1] == "old"{
		add = item
	} else {
		add = int64(first(strconv.Atoi(evalString[len(evalString)-1])))
	}
	if evalString[len(evalString)-2] == "+"{
		new = int64(float64(item + add)/float64(worryLevel))
	} else {
		new = int64(float64(item * add)/float64(worryLevel))
	}
	if allDivisable != 0 {
		new = new % allDivisable
	}
	//fmt.Println(new)
	m.OperationsCount = m.OperationsCount+1
	
	divisible := m.getDivisable()
	if math.Mod(float64(new),float64(divisible)) == 0.0 {
		finishString := strings.Split(m.Finish[0], " ")
		return first(strconv.Atoi(finishString[len(finishString)-1])), new
	}else{
		finishString := strings.Split(m.Finish[1], " ")
		return first(strconv.Atoi(finishString[len(finishString)-1])), new
	}
}

type Monkeys struct {
	MonkeyList []Monkey
	AllDivisable int64
}

func NewMonkeys(lines []string, useAllDivisable bool) *Monkeys {
	m := new(Monkeys)
	if useAllDivisable{
		m.AllDivisable = 1
	}
	for i, line := range lines {
		if strings.HasPrefix(line, "Monkey") {
			mo := *NewMonkey(lines[i+1:i+6])
			m.MonkeyList = append(m.MonkeyList, mo)
			if useAllDivisable{
				m.AllDivisable *= int64(mo.getDivisable())
			}
		}
	}
	return m
}

func (m *Monkeys) operateRounds(count int, worryLevel int) {
	var items []int64
	for i:=0;i<count;i++{
		for i, Monkey := range m.MonkeyList {
			items = Monkey.Items
			Monkey.Items = make([]int64, 0)
			for _, item := range items{
				finish, newItem := Monkey.operateItem(item, worryLevel, m.AllDivisable)
				m.MonkeyList[finish].Items = append(m.MonkeyList[finish].Items, newItem)
			}
			m.MonkeyList[i] = Monkey
		}
	}
}



func (p Day11) PartA(lines []string) any {
	monkeys := NewMonkeys(lines, false)
	monkeys.operateRounds(20, 3)
	var operationCounts []int
	for _, monkey := range monkeys.MonkeyList{
		operationCounts = append(operationCounts, monkey.OperationsCount)
	}
	sort.Ints(operationCounts)
	return operationCounts[len(operationCounts)-1]*operationCounts[len(operationCounts)-2]
}

func (p Day11) PartB(lines []string) any {
	monkeys := NewMonkeys(lines, true)
	monkeys.operateRounds(10000, 1)
	var operationCounts []int
	for _, monkey := range monkeys.MonkeyList{
		operationCounts = append(operationCounts, monkey.OperationsCount)
	}
	sort.Ints(operationCounts)
	return operationCounts[len(operationCounts)-1]*operationCounts[len(operationCounts)-2]
}
