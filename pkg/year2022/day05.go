// Code generated by aocgen; DO NOT EDIT.
package year2022

import (
	"fmt"
)

type Day05 struct{}


func (p Day05) PartA(lines []string) any {
	var crates [][]string = make([][]string,(len(lines[0])+1)/4)
	var init bool = false
	var count, start, finished int
	var move string
	var final string = ""
	for _, line := range lines {
		if init == false {
			//parse
			if string(line)=="" {
				// Empty Line
				init = true
				continue
			}
			if string(line[1]) == "1" {
				// Crade description
				continue
			}
			for j, char := range line {
				if string(char) != " " && string(char) != "[" && string(char) != "]" {
					position := (j+2)/4
					crates[position] = append([]string{string(char)}, crates[position]...)
				}
			}
		} else {
			// move
			fmt.Sscanf(line, "move %d from %d to %d", &count, &start, &finished)
			for i := 0; i < count; i++ {
				move = crates[start-1][len(crates[start-1])-(1)]
				crates[start-1] = crates[start-1][:len(crates[start-1])-(1)]
				crates[finished-1] = append(crates[finished-1], move)
			}
		}
	}
	for i, crate := range crates {
		// Make final string
		final += string(crate[len(crates[i])-1])
	}
	return final
}

func (p Day05) PartB(lines []string) any {	var crates [][]string = make([][]string,(len(lines[0])+1)/4)
	var init bool = false
	var count, start, finished int
	var move []string
	var final string = ""
	for _, line := range lines {
		if init == false {
			//parse
			if string(line)=="" {
				// Empty Line
				init = true
				continue
			}
			if string(line[1]) == "1" {
				// Crade description
				continue
			}
			for j, char := range line {
				if string(char) != " " && string(char) != "[" && string(char) != "]" {
					position := (j+2)/4
					crates[position] = append([]string{string(char)}, crates[position]...)
				}
			}
		} else {
			// move
			fmt.Sscanf(line, "move %d from %d to %d", &count, &start, &finished)
			move = crates[start-1][len(crates[start-1])-(1*count):]
			crates[start-1] = crates[start-1][:len(crates[start-1])-(1*count)]
			crates[finished-1] = append(crates[finished-1], move...)
		}
	}
	for i, crate := range crates {
		// Make final string
		final += string(crate[len(crates[i])-1])
	}
	return final
}
