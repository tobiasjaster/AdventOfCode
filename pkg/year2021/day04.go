// Code generated by aocgen; DO NOT EDIT.
package year2021

import (
	//"fmt"
	//"sort"
	"fmt"
	"strconv"
	"strings"
)

type Day04 struct{}

func first[T, U any](val T, _ U) T {
    return val
}

type Game struct {
	roundCounter int
	numbers []int
	bingos []Bingo
}

type Bingo struct{
	solved bool
	calculation int
	numbers [][]int
	template [][]string
}

func NewBingo(lines []string) *Bingo {
    b := new(Bingo)
	b.solved = false
	b.calculation = 0
	b.parseLines(lines)
    return b
}

func NewGame(lines []string) *Game {
    g := new(Game)
	g.roundCounter = 0
	g.bingos = make([]Bingo, 0)
	var numbLine = strings.ReplaceAll(lines[0], "\r", "")
	numbers := strings.Split(numbLine,",")
	for _, number := range numbers {
		g.numbers = append(g.numbers, first(strconv.Atoi(number)))
	}
	bingoLinesList := g.splitLines(lines[2:])
	for _, bingoLine := range bingoLinesList {
		g.bingos = append(g.bingos, *NewBingo(bingoLine))
	}
	return g
}

func (g Game) splitLines(lines []string) [][]string{
	var bingoLines [][]string
	var start int = -1
	for i ,line := range lines {
		if start == -1 && line != "" {
			start = i
			bingoLines = append(bingoLines, lines[i:i+5])
		}
		if start != -1 && line == "" {
			start = -1
		}
	}
	return bingoLines
}

func (g *Game) playRound() (bool,int){
	var number = g.roundCounter
	var returnNumber int = 0
	var winner bool = false
	for i, bingo := range g.bingos{
		if bingo.solved == true { continue }
		bingo.newNumber(g.numbers[number])
		if bingo.solved == true && winner != true {
			returnNumber = i
			winner = true
		}
	}
	g.roundCounter++
	return winner, returnNumber
}

func (b *Bingo) parseLines(lines []string) {
	b.numbers = make([][]int,0)
	b.template = make([][]string,0)
	b.numbers = append(b.numbers, make([]int,0))
	b.template = append(b.template, make([]string,0))
	b.numbers = append(b.numbers, make([]int,0))
	b.template = append(b.template, make([]string,0))
	b.numbers = append(b.numbers, make([]int,0))
	b.template = append(b.template, make([]string,0))
	b.numbers = append(b.numbers, make([]int,0))
	b.template = append(b.template, make([]string,0))
	b.numbers = append(b.numbers, make([]int,0))
	b.template = append(b.template, make([]string,0))
	for i, line := range lines {
		line = strings.ReplaceAll(line, "\r", "")
		line = strings.ReplaceAll(line, "  ", " ")
		line = strings.TrimSpace(line)
		numbers := strings.Split(line," ")
		for _, number := range numbers {
			b.numbers[i] = append(b.numbers[i],first(strconv.Atoi(number)))
			b.template[i] = append(b.template[i], "*")
		}
	}
}

func (b *Bingo) newNumber(number int) bool {
	var check bool
	var notChecked int = 0
	if b.solved == true { return true }
	for i := 0; i < 5; i++ {
		for j := 0; j < 5; j++ {
			if b.numbers[i][j] == number { b.template[i][j] = "X" }
		}
	}
	for i := 0; i < 5; i++ {
		check = true
		for j := 0; j < 5; j++ {
			if b.template[i][j] != "X" { check = false; break; }
		}
		if check == true { break; }
		check = true
		for j := 0; j < 5; j++ {
			if b.template[j][i] != "X" { check = false; break; }
		}
		if check == true { break; }
	}
	if check {
		for i := 0; i < 5; i++ {
			for j := 0; j < 5; j++ {
				if b.template[i][j] != "X" { notChecked += b.numbers[i][j] }
			}
		}
		b.setSolved(notChecked*number)
		return true
	}
	return false
}

func (b *Bingo) setSolved(calculation int) {
	b.solved = true
	b.calculation = calculation
}

func (b *Bingo) getCalculation() int{
	return b.calculation
}

func (p Day04) PartA(lines []string) any {
	var game Game = *NewGame(lines)
	var calcNumber int
	for i := 1; i < len(game.numbers); i++ {
		winner, bingoNumber := game.playRound()
		fmt.Println(winner, game.bingos[bingoNumber].getCalculation())
		if winner == true {
			calcNumber = game.bingos[bingoNumber].calculation
			break
		}
	}
	return strconv.Itoa(calcNumber)
}

func (p Day04) PartB(lines []string) any {
	// var game Game = *NewGame(lines)
	// var calcNumber []int
	// for i := 1; i < len(game.numbers); i++ {
	// 	game.playRound()
	// }
	// for i := 1; i < len(game.bingos); i++ {
	// 	calcNumber = append(calcNumber, game.bingos[i].calculation)
	// }
	// sort.Slice(calcNumber, func(i, j int) bool { return calcNumber[i] > calcNumber[j] })
	// return strconv.Itoa(calcNumber[0])
	return "calcNumber"
}
