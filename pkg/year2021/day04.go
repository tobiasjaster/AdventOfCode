// Code generated by aocgen; DO NOT EDIT.
package year2021

import (
	"strconv"
	"strings"
)

type Day04 struct{}

type Game struct {
	roundCounter int
	numbers []int
	bingos []Bingo
}

type Bingo struct {
	solved bool
	calculation int
	lastNumber int
	numbers [][]int
	template [][]string
}

func NewBingo(lines []string) *Bingo {
    b := new(Bingo)
	b.solved = false
	b.calculation = 0
	b.lastNumber = 0
	b.parseLines(lines)
    return b
}

func NewGame(lines []string) *Game {
    g := new(Game)
	g.roundCounter = 0
	g.bingos = make([]Bingo, 0)
	var numbLine = strings.ReplaceAll(lines[0], "\r", "")
	numbers := strings.Split(numbLine,",")
	for _, number := range numbers { g.numbers = append(g.numbers, first(strconv.Atoi(number))) }
	bingoLinesList := splitLines(lines[2:])
	for _, bingoLine := range bingoLinesList { g.bingos = append(g.bingos, *NewBingo(bingoLine)) }
	return g
}

func splitLines(lines []string) [][]string{
	var bingoLines [][]string
	var start int = -1
	for i ,line := range lines {
		if start == -1 && line != "" {
			start = i
			bingoLines = append(bingoLines, lines[i:i+5])
		}
		if start != -1 && line == "" { start = -1 }
	}
	return bingoLines
}

func (g *Game) playRound() bool{
	g.roundCounter++
	var winner bool = false
	for i, bingo := range g.bingos{
		if bingo.solved == true { continue }
		bingo.newNumber(g.numbers[g.roundCounter-1])
		if bingo.checkBingo() == true && !bingo.solved{
			bingo.solved = true
			bingo.calculation = bingo.calcUnchecked()*g.numbers[g.roundCounter-1]
			if winner != true { winner = true }
		}
		g.bingos[i] = bingo
	}
	return winner
}

func (g *Game) getFirstSolved() int {
	for _, bingo := range g.bingos {
		if bingo.solved { return bingo.calculation }
	}
	return 0
}

func (g *Game) getLastSolved() int {
	var calculation int = 0
	for _, number := range reverse(g.numbers) {
		if calculation != 0 { break }
		for _, bingo := range g.bingos{
			if bingo.lastNumber == number{
				calculation=bingo.calculation
				break
			}
		}
	}
	return calculation
}

func (b *Bingo) parseLines(lines []string) {
	b.numbers = make([][]int,5)
	b.template = make([][]string,5)
	for i, line := range lines {
		line = strings.ReplaceAll(line, "\r", "")
		line = strings.ReplaceAll(line, "  ", " ")
		line = strings.TrimSpace(line)
		numbers := strings.Split(line," ")
		for _, number := range numbers {
			b.numbers[i] = append(b.numbers[i],first(strconv.Atoi(number)))
			b.template[i] = append(b.template[i], "*")
		}
	}
}

func (b *Bingo) newNumber(number int) {
	if b.solved == true { return }
	for i := 0; i < 5; i++ {
		for j := 0; j < 5; j++ {
			if b.numbers[i][j] == number { b.template[i][j] = "X" }
		}
	}
	b.lastNumber = number
}

func (b *Bingo) checkBingo() bool {
	var check bool
	for i := 0; i < 5; i++ {
		check = true
		for j := 0; j < 5; j++ {
			if b.template[i][j] != "X" { check = false; break; }
		}
		if check == true { break; }
		check = true
		for j := 0; j < 5; j++ {
			if b.template[j][i] != "X" { check = false; break; }
		}
		if check == true { break; }
	}
	return check
}

func (b Bingo) calcUnchecked() int {
	var notChecked int
	for i := 0; i < 5; i++ {
		for j := 0; j < 5; j++ {
			if b.template[i][j] != "X" { notChecked += b.numbers[i][j] }
		}
	}
	return notChecked
}

func (b *Bingo) getCalculation() int{
	return b.calculation
}

func (p Day04) PartA(lines []string) any {
	var game Game = *NewGame(lines)
	for i := 1; i < len(game.numbers); i++ {
		winner := game.playRound()
		if winner == true { break }
	}
	return game.getFirstSolved()
}

func (p Day04) PartB(lines []string) any {
	var game Game = *NewGame(lines)
	for i := 1; i < len(game.numbers); i++ { game.playRound() }
	return game.getLastSolved()
}
