// Code generated by aocgen; DO NOT EDIT.
package year2021

import (
	"fmt"
	"strconv"
	"strings"
)

type Day03 struct{}

type Report struct{
	bits [][]int
}

func (r *Report) addReportLine(charArray []rune){
	var initial bool = len(r.bits) == 0
	for i, value := range charArray {
		bit, _ := strconv.Atoi(string(value))
		if initial {
			r.bits = append(r.bits, []int{bit})
		}else{
			r.bits[i] = append(r.bits[i], bit)
		}
	}
}

func (r *Report) getSliceLineNumbers() []int {
	var lineNumbers []int
	for i, _ := range r.bits[0] {
		lineNumbers = append(lineNumbers, i)
	}
	return lineNumbers
}

type Submarine struct{
	gamma int
	epsilon int
	oxygen int
	scrubber int
}

func (s *Submarine) calcPower(report *Report) {
	s.gamma = 0
	s.epsilon = 0
	var counter int
	for i, values := range report.bits {
		counter = 0
		for _, bit := range values {
			if bit == 1 { counter++ }
		}
		if counter > (len(values)/2) {
			s.gamma += 1<<(len(report.bits)-1-i)
		}else{
			s.epsilon += 1<<(len(report.bits)-1-i)
		}
	}
}

func (s *Submarine) calcOxygen(report *Report) {
	var oxygenNumbers []int = report.getSliceLineNumbers()
	var scrubberNumbers []int = report.getSliceLineNumbers()
	var ones []int
	var zeros []int
	s.oxygen = 0
	s.scrubber = 0
	var oxygenNumber int = -1
	var scrubberNumber int = -1
	for i := 0; i < len(report.bits); i++ {
		if oxygenNumber == -1 {
			ones = make([]int, 0)
			zeros = make([]int, 0)
			for _, lineNumber := range oxygenNumbers {
				if report.bits[i][lineNumber] == 1 { 
					ones = append(ones, lineNumber) 
				} else { 
					zeros = append(zeros, lineNumber) 
				}
			}

			if len(ones) < (len(oxygenNumbers)/2) {
				oxygenNumbers = ones
			}else{
				oxygenNumbers = zeros
			}
			fmt.Println(oxygenNumbers)
			if len(oxygenNumbers) == 1 { oxygenNumber = oxygenNumbers[0] }
		}
		if scrubberNumber == -1 {
			ones = make([]int, 0)
			zeros = make([]int, 0)
			for _, lineNumber := range scrubberNumbers {
				if report.bits[i][lineNumber] == 1 { ones = append(ones, lineNumber) } else { zeros = append(zeros, lineNumber) }
			}
			if len(zeros) > (len(scrubberNumbers)/2) {
				scrubberNumbers = zeros
			}else{
				scrubberNumbers = ones
			}
			if len(scrubberNumbers) == 1 { scrubberNumber = scrubberNumbers[0] }
		}
	}
	for i, values := range report.bits {
		s.oxygen += values[oxygenNumber]<<(len(report.bits)-1-i)
		s.scrubber += values[scrubberNumber]<<(len(report.bits)-1-i)
	}
}

func (s *Submarine) getPower(report *Report) int{
	s.calcPower(report)
	return s.gamma*s.epsilon
}

func (s *Submarine) getLifeSupport(report *Report) int{
	s.calcOxygen(report)
	return s.oxygen*s.scrubber
}


func (p Day03) PartA(lines []string) any {
	var report Report
	var submarine Submarine
	for _, value := range lines {
		chars := []rune(strings.ReplaceAll(string(value), "\r", ""))
		report.addReportLine(chars)
	}
	return submarine.getPower(&report)
}

func (p Day03) PartB(lines []string) any {
	var report Report
	var submarine Submarine
	for _, value := range lines {
		chars := []rune(strings.ReplaceAll(string(value), "\r", ""))
		report.addReportLine(chars)
	}
	return submarine.getLifeSupport(&report)
}
